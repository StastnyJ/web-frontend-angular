/**
 * web-backend-swagger
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { AchievementCreationRequest } from '../model/achievementCreationRequest';
import { AchievementResponse } from '../model/achievementResponse';
import { AchievementsResponse } from '../model/achievementsResponse';
import { ArticleCreationRequest } from '../model/articleCreationRequest';
import { ArticleResponse } from '../model/articleResponse';
import { ArticlesResponse } from '../model/articlesResponse';
import { AuthResponse } from '../model/authResponse';
import { BasicProfileResponse } from '../model/basicProfileResponse';
import { ChangePasswordRequest } from '../model/changePasswordRequest';
import { ChangePasswordResult } from '../model/changePasswordResult';
import { EmptyDict } from '../model/emptyDict';
import { FeedbackCreationRequest } from '../model/feedbackCreationRequest';
import { FeedbackRequest } from '../model/feedbackRequest';
import { FeedbackResponse } from '../model/feedbackResponse';
import { FeedbackUpdateRequest } from '../model/feedbackUpdateRequest';
import { FeedbacksResponse } from '../model/feedbacksResponse';
import { ForgottenPasswordRequest } from '../model/forgottenPasswordRequest';
import { ForgottenPasswordResult } from '../model/forgottenPasswordResult';
import { InlineResponse200 } from '../model/inlineResponse200';
import { ModuleResponse } from '../model/moduleResponse';
import { ModuleSubmissionRequest } from '../model/moduleSubmissionRequest';
import { ModuleSubmitResponse } from '../model/moduleSubmitResponse';
import { PostResponse } from '../model/postResponse';
import { PostsCreationRequest } from '../model/postsCreationRequest';
import { PostsEditRequest } from '../model/postsEditRequest';
import { ProfileEdit } from '../model/profileEdit';
import { ProfileResponse } from '../model/profileResponse';
import { RegistrationRequest } from '../model/registrationRequest';
import { RunCodeRequest } from '../model/runCodeRequest';
import { RunCodeResponse } from '../model/runCodeResponse';
import { TaskDetailResponse } from '../model/taskDetailResponse';
import { TaskResponse } from '../model/taskResponse';
import { TasksResponse } from '../model/tasksResponse';
import { ThreadDetailResponse } from '../model/threadDetailResponse';
import { ThreadResponse } from '../model/threadResponse';
import { ThreadsCreationRequest } from '../model/threadsCreationRequest';
import { ThreadsResponse } from '../model/threadsResponse';
import { Uint8Array } from '../model/uint8Array';
import { UserResponse } from '../model/userResponse';
import { UsersResponse } from '../model/usersResponse';
import { WaveCreationRequest } from '../model/waveCreationRequest';
import { WaveResponse } from '../model/waveResponse';
import { WaveUpdateRequest } from '../model/waveUpdateRequest';
import { Waves } from '../model/waves';
import { YearCreationRequest } from '../model/yearCreationRequest';
import { YearResponse } from '../model/yearResponse';
import { YearUpdateRequest } from '../model/yearUpdateRequest';
import { Years } from '../model/years';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DefaultService {

    protected basePath = '/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public achievementsCreateNew(body: AchievementCreationRequest, observe?: 'body', reportProgress?: boolean): Observable<AchievementCreationRequest>;
    public achievementsCreateNew(body: AchievementCreationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AchievementCreationRequest>>;
    public achievementsCreateNew(body: AchievementCreationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AchievementCreationRequest>>;
    public achievementsCreateNew(body: AchievementCreationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling achievementsCreateNew.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<AchievementCreationRequest>('post',`${this.basePath}/achievements`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param achievementId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public achievementsDeleteSingle(achievementId: number, observe?: 'body', reportProgress?: boolean): Observable<EmptyDict>;
    public achievementsDeleteSingle(achievementId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyDict>>;
    public achievementsDeleteSingle(achievementId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyDict>>;
    public achievementsDeleteSingle(achievementId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (achievementId === null || achievementId === undefined) {
            throw new Error('Required parameter achievementId was null or undefined when calling achievementsDeleteSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyDict>('delete',`${this.basePath}/achievements/${encodeURIComponent(String(achievementId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param achievementId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public achievementsEditSingle(body: AchievementCreationRequest, achievementId: number, observe?: 'body', reportProgress?: boolean): Observable<AchievementResponse>;
    public achievementsEditSingle(body: AchievementCreationRequest, achievementId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AchievementResponse>>;
    public achievementsEditSingle(body: AchievementCreationRequest, achievementId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AchievementResponse>>;
    public achievementsEditSingle(body: AchievementCreationRequest, achievementId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling achievementsEditSingle.');
        }

        if (achievementId === null || achievementId === undefined) {
            throw new Error('Required parameter achievementId was null or undefined when calling achievementsEditSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<AchievementResponse>('put',`${this.basePath}/achievements/${encodeURIComponent(String(achievementId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param limit 
     * @param start 
     * @param achievement 
     * @param year 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public achievementsGetAll(limit?: number, start?: number, achievement?: number, year?: number, observe?: 'body', reportProgress?: boolean): Observable<AchievementsResponse>;
    public achievementsGetAll(limit?: number, start?: number, achievement?: number, year?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AchievementsResponse>>;
    public achievementsGetAll(limit?: number, start?: number, achievement?: number, year?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AchievementsResponse>>;
    public achievementsGetAll(limit?: number, start?: number, achievement?: number, year?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('_limit', <any>limit);
        }
        if (start !== undefined && start !== null) {
            queryParameters = queryParameters.set('_start', <any>start);
        }

        let headers = this.defaultHeaders;
        if (achievement !== undefined && achievement !== null) {
            headers = headers.set('achievement', String(achievement));
        }
        if (year !== undefined && year !== null) {
            headers = headers.set('year', String(year));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AchievementsResponse>('get',`${this.basePath}/achievements`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param achievementId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public achievementsGetSingle(achievementId: number, observe?: 'body', reportProgress?: boolean): Observable<AchievementResponse>;
    public achievementsGetSingle(achievementId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AchievementResponse>>;
    public achievementsGetSingle(achievementId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AchievementResponse>>;
    public achievementsGetSingle(achievementId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (achievementId === null || achievementId === undefined) {
            throw new Error('Required parameter achievementId was null or undefined when calling achievementsGetSingle.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AchievementResponse>('get',`${this.basePath}/achievements/${encodeURIComponent(String(achievementId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public articlesCreateNew(body: ArticleCreationRequest, observe?: 'body', reportProgress?: boolean): Observable<ArticleCreationRequest>;
    public articlesCreateNew(body: ArticleCreationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArticleCreationRequest>>;
    public articlesCreateNew(body: ArticleCreationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArticleCreationRequest>>;
    public articlesCreateNew(body: ArticleCreationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling articlesCreateNew.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ArticleCreationRequest>('post',`${this.basePath}/articles`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param articleId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public articlesDeleteSingle(articleId: number, observe?: 'body', reportProgress?: boolean): Observable<EmptyDict>;
    public articlesDeleteSingle(articleId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyDict>>;
    public articlesDeleteSingle(articleId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyDict>>;
    public articlesDeleteSingle(articleId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (articleId === null || articleId === undefined) {
            throw new Error('Required parameter articleId was null or undefined when calling articlesDeleteSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyDict>('delete',`${this.basePath}/articles/${encodeURIComponent(String(articleId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param articleId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public articlesEditSingle(body: ArticleCreationRequest, articleId: number, observe?: 'body', reportProgress?: boolean): Observable<ArticleResponse>;
    public articlesEditSingle(body: ArticleCreationRequest, articleId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArticleResponse>>;
    public articlesEditSingle(body: ArticleCreationRequest, articleId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArticleResponse>>;
    public articlesEditSingle(body: ArticleCreationRequest, articleId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling articlesEditSingle.');
        }

        if (articleId === null || articleId === undefined) {
            throw new Error('Required parameter articleId was null or undefined when calling articlesEditSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ArticleResponse>('put',`${this.basePath}/articles/${encodeURIComponent(String(articleId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param limit 
     * @param start 
     * @param article 
     * @param year 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public articlesGetAll(limit?: number, start?: number, article?: number, year?: number, observe?: 'body', reportProgress?: boolean): Observable<ArticlesResponse>;
    public articlesGetAll(limit?: number, start?: number, article?: number, year?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArticlesResponse>>;
    public articlesGetAll(limit?: number, start?: number, article?: number, year?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArticlesResponse>>;
    public articlesGetAll(limit?: number, start?: number, article?: number, year?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('_limit', <any>limit);
        }
        if (start !== undefined && start !== null) {
            queryParameters = queryParameters.set('_start', <any>start);
        }

        let headers = this.defaultHeaders;
        if (article !== undefined && article !== null) {
            headers = headers.set('article', String(article));
        }
        if (year !== undefined && year !== null) {
            headers = headers.set('year', String(year));
        }

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ArticlesResponse>('get',`${this.basePath}/articles`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param articleId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public articlesGetSingle(articleId: number, observe?: 'body', reportProgress?: boolean): Observable<ArticleResponse>;
    public articlesGetSingle(articleId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ArticleResponse>>;
    public articlesGetSingle(articleId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ArticleResponse>>;
    public articlesGetSingle(articleId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (articleId === null || articleId === undefined) {
            throw new Error('Required parameter articleId was null or undefined when calling articlesGetSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ArticleResponse>('get',`${this.basePath}/articles/${encodeURIComponent(String(articleId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param grantType 
     * @param username 
     * @param password 
     * @param refreshToken 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    // @ts-ignore
    public  authorizeForm(grantType: string, username: string = "", password: string = "", refreshToken: string = "", observe?: 'body', reportProgress?: boolean): Observable<AuthResponse>;
    // @ts-ignore
    public  authorizeForm(grantType: string, username: string = "", password: string = "", refreshToken: string = "", observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AuthResponse>>;
    // @ts-ignore
    public  authorizeForm(grantType: string, username: string = "", password: string = "", refreshToken: string = "", observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AuthResponse>>;
    // @ts-ignore
    public  authorizeForm(grantType: string, username: string = "", password: string = "", refreshToken: string = "", observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (grantType === null || grantType === undefined) {
            throw new Error('Required parameter grantType was null or undefined when calling authorize.');
        }

        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling authorize.');
        }

        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling authorize.');
        }

        if (refreshToken === null || refreshToken === undefined) {
            throw new Error('Required parameter refreshToken was null or undefined when calling authorize.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (grantType !== undefined) {
            formParams = formParams.append('grant_type', <any>grantType) as any || formParams;
        }
        if (username !== undefined) {
            formParams = formParams.append('username', <any>username) as any || formParams;
        }
        if (password !== undefined) {
            formParams = formParams.append('password', <any>password) as any || formParams;
        }
        if (refreshToken !== undefined) {
            formParams = formParams.append('refresh_token', <any>refreshToken) as any || formParams;
        }

        return this.httpClient.request<AuthResponse>('post',`${this.basePath}/auth`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public basicProfileGetSingle(observe?: 'body', reportProgress?: boolean): Observable<BasicProfileResponse>;
    public basicProfileGetSingle(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BasicProfileResponse>>;
    public basicProfileGetSingle(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BasicProfileResponse>>;
    public basicProfileGetSingle(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<BasicProfileResponse>('get',`${this.basePath}/basicProfile`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param files 
     * @param path 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public contentsCreateNewForm(files: Array<Blob>, path?: string, observe?: 'body', reportProgress?: boolean): Observable<EmptyDict>;
    public contentsCreateNewForm(files: Array<Blob>, path?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyDict>>;
    public contentsCreateNewForm(files: Array<Blob>, path?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyDict>>;
    public contentsCreateNewForm(files: Array<Blob>, path?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (files === null || files === undefined) {
            throw new Error('Required parameter files was null or undefined when calling contentsCreateNew.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (path !== undefined && path !== null) {
            queryParameters = queryParameters.set('path', <any>path);
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<EmptyDict>('post',`${this.basePath}/content`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public contentsDeleteSingle(path?: string, observe?: 'body', reportProgress?: boolean): Observable<EmptyDict>;
    public contentsDeleteSingle(path?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyDict>>;
    public contentsDeleteSingle(path?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyDict>>;
    public contentsDeleteSingle(path?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (path !== undefined && path !== null) {
            queryParameters = queryParameters.set('path', <any>path);
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyDict>('delete',`${this.basePath}/content`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public contentsGetSingle(path?: string, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse200>;
    public contentsGetSingle(path?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse200>>;
    public contentsGetSingle(path?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse200>>;
    public contentsGetSingle(path?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (path !== undefined && path !== null) {
            queryParameters = queryParameters.set('path', <any>path);
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse200>('get',`${this.basePath}/content`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public feedbackCreateNew(body: FeedbackCreationRequest, observe?: 'body', reportProgress?: boolean): Observable<FeedbackCreationRequest>;
    public feedbackCreateNew(body: FeedbackCreationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeedbackCreationRequest>>;
    public feedbackCreateNew(body: FeedbackCreationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeedbackCreationRequest>>;
    public feedbackCreateNew(body: FeedbackCreationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling feedbackCreateNew.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<FeedbackCreationRequest>('post',`${this.basePath}/feedbacks`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param feedbackId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public feedbackDeleteSingle(feedbackId: number, observe?: 'body', reportProgress?: boolean): Observable<EmptyDict>;
    public feedbackDeleteSingle(feedbackId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyDict>>;
    public feedbackDeleteSingle(feedbackId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyDict>>;
    public feedbackDeleteSingle(feedbackId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (feedbackId === null || feedbackId === undefined) {
            throw new Error('Required parameter feedbackId was null or undefined when calling feedbackDeleteSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyDict>('delete',`${this.basePath}/feedbacks/${encodeURIComponent(String(feedbackId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param feedbackId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public feedbackEditSingle(body: FeedbackUpdateRequest, feedbackId: number, observe?: 'body', reportProgress?: boolean): Observable<FeedbacksResponse>;
    public feedbackEditSingle(body: FeedbackUpdateRequest, feedbackId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeedbacksResponse>>;
    public feedbackEditSingle(body: FeedbackUpdateRequest, feedbackId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeedbacksResponse>>;
    public feedbackEditSingle(body: FeedbackUpdateRequest, feedbackId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling feedbackEditSingle.');
        }

        if (feedbackId === null || feedbackId === undefined) {
            throw new Error('Required parameter feedbackId was null or undefined when calling feedbackEditSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<FeedbacksResponse>('put',`${this.basePath}/feedbacks/${encodeURIComponent(String(feedbackId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param feedbackId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public feedbackGetSingle(feedbackId: number, observe?: 'body', reportProgress?: boolean): Observable<FeedbacksResponse>;
    public feedbackGetSingle(feedbackId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeedbacksResponse>>;
    public feedbackGetSingle(feedbackId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeedbacksResponse>>;
    public feedbackGetSingle(feedbackId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (feedbackId === null || feedbackId === undefined) {
            throw new Error('Required parameter feedbackId was null or undefined when calling feedbackGetSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FeedbacksResponse>('get',`${this.basePath}/feedbacks/${encodeURIComponent(String(feedbackId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public forgottenPasswordReset(body: ForgottenPasswordRequest, observe?: 'body', reportProgress?: boolean): Observable<ForgottenPasswordResult>;
    public forgottenPasswordReset(body: ForgottenPasswordRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ForgottenPasswordResult>>;
    public forgottenPasswordReset(body: ForgottenPasswordRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ForgottenPasswordResult>>;
    public forgottenPasswordReset(body: ForgottenPasswordRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling forgottenPasswordReset.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ForgottenPasswordResult>('post',`${this.basePath}/forgottenPassword`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public forgottenPasswordReset_1(body: ChangePasswordRequest, observe?: 'body', reportProgress?: boolean): Observable<ChangePasswordResult>;
    public forgottenPasswordReset_1(body: ChangePasswordRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ChangePasswordResult>>;
    public forgottenPasswordReset_1(body: ChangePasswordRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ChangePasswordResult>>;
    public forgottenPasswordReset_1(body: ChangePasswordRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling forgottenPasswordReset_1.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ChangePasswordResult>('post',`${this.basePath}/settings/changePassword`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param context 
     * @param imagesId 
     * @param file 
     * @param module 
     * @param user 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public imagesGetSingle(context: string, imagesId: number, file?: string, module?: number, user?: number, observe?: 'body', reportProgress?: boolean): Observable<Uint8Array>;
    public imagesGetSingle(context: string, imagesId: number, file?: string, module?: number, user?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Uint8Array>>;
    public imagesGetSingle(context: string, imagesId: number, file?: string, module?: number, user?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Uint8Array>>;
    public imagesGetSingle(context: string, imagesId: number, file?: string, module?: number, user?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (context === null || context === undefined) {
            throw new Error('Required parameter context was null or undefined when calling imagesGetSingle.');
        }

        if (imagesId === null || imagesId === undefined) {
            throw new Error('Required parameter imagesId was null or undefined when calling imagesGetSingle.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (file !== undefined && file !== null) {
            queryParameters = queryParameters.set('file', <any>file);
        }
        if (module !== undefined && module !== null) {
            queryParameters = queryParameters.set('module', <any>module);
        }
        if (user !== undefined && user !== null) {
            queryParameters = queryParameters.set('user', <any>user);
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Uint8Array>('get',`${this.basePath}/images/${encodeURIComponent(String(context))}/${encodeURIComponent(String(imagesId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param modulesId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modulesGetSingle(modulesId: number, observe?: 'body', reportProgress?: boolean): Observable<ModuleResponse>;
    public modulesGetSingle(modulesId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModuleResponse>>;
    public modulesGetSingle(modulesId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModuleResponse>>;
    public modulesGetSingle(modulesId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (modulesId === null || modulesId === undefined) {
            throw new Error('Required parameter modulesId was null or undefined when calling modulesGetSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ModuleResponse>('get',`${this.basePath}/modules/${encodeURIComponent(String(modulesId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param files 
     * @param modulesId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modulesSubmitFilesForm(files: Blob, modulesId: number, observe?: 'body', reportProgress?: boolean): Observable<ModuleSubmitResponse>;
    public modulesSubmitFilesForm(files: Blob, modulesId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModuleSubmitResponse>>;
    public modulesSubmitFilesForm(files: Blob, modulesId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModuleSubmitResponse>>;
    public modulesSubmitFilesForm(files: Blob, modulesId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (files === null || files === undefined) {
            throw new Error('Required parameter files was null or undefined when calling modulesSubmitFiles.');
        }

        if (modulesId === null || modulesId === undefined) {
            throw new Error('Required parameter modulesId was null or undefined when calling modulesSubmitFiles.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files !== undefined) {
            formParams = formParams.append('files', <any>files) as any || formParams;
        }

        return this.httpClient.request<ModuleSubmitResponse>('post',`${this.basePath}/modules/${encodeURIComponent(String(modulesId))}/submitFiles`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param modulesId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modulesSubmitSingle(modulesId: number, body?: ModuleSubmissionRequest, observe?: 'body', reportProgress?: boolean): Observable<ModuleSubmitResponse>;
    public modulesSubmitSingle(modulesId: number, body?: ModuleSubmissionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModuleSubmitResponse>>;
    public modulesSubmitSingle(modulesId: number, body?: ModuleSubmissionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModuleSubmitResponse>>;
    public modulesSubmitSingle(modulesId: number, body?: ModuleSubmissionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (modulesId === null || modulesId === undefined) {
            throw new Error('Required parameter modulesId was null or undefined when calling modulesSubmitSingle.');
        }


        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ModuleSubmitResponse>('post',`${this.basePath}/modules/${encodeURIComponent(String(modulesId))}/submit`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postsCreateNew(body: PostsCreationRequest, observe?: 'body', reportProgress?: boolean): Observable<PostsCreationRequest>;
    public postsCreateNew(body: PostsCreationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PostsCreationRequest>>;
    public postsCreateNew(body: PostsCreationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PostsCreationRequest>>;
    public postsCreateNew(body: PostsCreationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postsCreateNew.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<PostsCreationRequest>('post',`${this.basePath}/posts`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param postsId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postsDeleteSingle(postsId: number, observe?: 'body', reportProgress?: boolean): Observable<EmptyDict>;
    public postsDeleteSingle(postsId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyDict>>;
    public postsDeleteSingle(postsId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyDict>>;
    public postsDeleteSingle(postsId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (postsId === null || postsId === undefined) {
            throw new Error('Required parameter postsId was null or undefined when calling postsDeleteSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyDict>('delete',`${this.basePath}/posts/${encodeURIComponent(String(postsId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param postsId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postsEditSingle(body: PostsEditRequest, postsId: number, observe?: 'body', reportProgress?: boolean): Observable<PostResponse>;
    public postsEditSingle(body: PostsEditRequest, postsId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PostResponse>>;
    public postsEditSingle(body: PostsEditRequest, postsId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PostResponse>>;
    public postsEditSingle(body: PostsEditRequest, postsId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postsEditSingle.');
        }

        if (postsId === null || postsId === undefined) {
            throw new Error('Required parameter postsId was null or undefined when calling postsEditSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<PostResponse>('put',`${this.basePath}/posts/${encodeURIComponent(String(postsId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param postsId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postsGetSingle(postsId: number, observe?: 'body', reportProgress?: boolean): Observable<PostResponse>;
    public postsGetSingle(postsId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PostResponse>>;
    public postsGetSingle(postsId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PostResponse>>;
    public postsGetSingle(postsId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (postsId === null || postsId === undefined) {
            throw new Error('Required parameter postsId was null or undefined when calling postsGetSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<PostResponse>('get',`${this.basePath}/posts/${encodeURIComponent(String(postsId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public profileEditMy(body: ProfileEdit, observe?: 'body', reportProgress?: boolean): Observable<ProfileResponse>;
    public profileEditMy(body: ProfileEdit, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProfileResponse>>;
    public profileEditMy(body: ProfileEdit, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProfileResponse>>;
    public profileEditMy(body: ProfileEdit, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling profileEditMy.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ProfileResponse>('put',`${this.basePath}/profile`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public profileGetMy(observe?: 'body', reportProgress?: boolean): Observable<ProfileResponse>;
    public profileGetMy(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProfileResponse>>;
    public profileGetMy(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProfileResponse>>;
    public profileGetMy(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ProfileResponse>('get',`${this.basePath}/profile`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param profileId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public profileGetSingle(profileId: number, observe?: 'body', reportProgress?: boolean): Observable<ProfileResponse>;
    public profileGetSingle(profileId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProfileResponse>>;
    public profileGetSingle(profileId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProfileResponse>>;
    public profileGetSingle(profileId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (profileId === null || profileId === undefined) {
            throw new Error('Required parameter profileId was null or undefined when calling profileGetSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ProfileResponse>('get',`${this.basePath}/profile/${encodeURIComponent(String(profileId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param file 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public profileUploadPictureForm(file: Blob, observe?: 'body', reportProgress?: boolean): Observable<EmptyDict>;
    public profileUploadPictureForm(file: Blob, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyDict>>;
    public profileUploadPictureForm(file: Blob, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyDict>>;
    public profileUploadPictureForm(file: Blob, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling profileUploadPicture.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (file !== undefined) {
            formParams = formParams.append('file', <any>file) as any || formParams;
        }

        return this.httpClient.request<EmptyDict>('post',`${this.basePath}/profile/picture`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registerNewUser(body: RegistrationRequest, observe?: 'body', reportProgress?: boolean): Observable<EmptyDict>;
    public registerNewUser(body: RegistrationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyDict>>;
    public registerNewUser(body: RegistrationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyDict>>;
    public registerNewUser(body: RegistrationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling registerNewUser.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<EmptyDict>('post',`${this.basePath}/registration`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param moduleId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public runCode(body: RunCodeRequest, moduleId: number, observe?: 'body', reportProgress?: boolean): Observable<RunCodeResponse>;
    public runCode(body: RunCodeRequest, moduleId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RunCodeResponse>>;
    public runCode(body: RunCodeRequest, moduleId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RunCodeResponse>>;
    public runCode(body: RunCodeRequest, moduleId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling runCode.');
        }

        if (moduleId === null || moduleId === undefined) {
            throw new Error('Required parameter moduleId was null or undefined when calling runCode.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<RunCodeResponse>('post',`${this.basePath}/runCode/${encodeURIComponent(String(moduleId))}/submit`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sendEmailWithFeedback(body: FeedbackRequest, observe?: 'body', reportProgress?: boolean): Observable<FeedbackResponse>;
    public sendEmailWithFeedback(body: FeedbackRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeedbackResponse>>;
    public sendEmailWithFeedback(body: FeedbackRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeedbackResponse>>;
    public sendEmailWithFeedback(body: FeedbackRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling sendEmailWithFeedback.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<FeedbackResponse>('post',`${this.basePath}/feedback`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sendEmailWithFeedback_2(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public sendEmailWithFeedback_2(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public sendEmailWithFeedback_2(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public sendEmailWithFeedback_2(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('get',`${this.basePath}/logout`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param submFileId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subFilesDeleteSingle(submFileId: number, observe?: 'body', reportProgress?: boolean): Observable<EmptyDict>;
    public subFilesDeleteSingle(submFileId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyDict>>;
    public subFilesDeleteSingle(submFileId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyDict>>;
    public subFilesDeleteSingle(submFileId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (submFileId === null || submFileId === undefined) {
            throw new Error('Required parameter submFileId was null or undefined when calling subFilesDeleteSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyDict>('delete',`${this.basePath}/submFiles/${encodeURIComponent(String(submFileId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param submFileId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public submFilesGetSingle(submFileId: number, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public submFilesGetSingle(submFileId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public submFilesGetSingle(submFileId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public submFilesGetSingle(submFileId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (submFileId === null || submFileId === undefined) {
            throw new Error('Required parameter submFileId was null or undefined when calling submFilesGetSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Blob>('get',`${this.basePath}/submFiles/${encodeURIComponent(String(submFileId))}`,//@ts-ignore
{responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param view 
     * @param contentId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public taskContent2GetSingle(view: string, contentId: string, observe?: 'body', reportProgress?: boolean): Observable<Uint8Array>;
    public taskContent2GetSingle(view: string, contentId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Uint8Array>>;
    public taskContent2GetSingle(view: string, contentId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Uint8Array>>;
    public taskContent2GetSingle(view: string, contentId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (view === null || view === undefined) {
            throw new Error('Required parameter view was null or undefined when calling taskContent2GetSingle.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling taskContent2GetSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Uint8Array>('get',`${this.basePath}/taskContent/${encodeURIComponent(String(contentId))}/${encodeURIComponent(String(view))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param view 
     * @param contentId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public taskContentGetSingle(view: string, contentId: string, observe?: 'body', reportProgress?: boolean): Observable<Uint8Array>;
    public taskContentGetSingle(view: string, contentId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Uint8Array>>;
    public taskContentGetSingle(view: string, contentId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Uint8Array>>;
    public taskContentGetSingle(view: string, contentId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (view === null || view === undefined) {
            throw new Error('Required parameter view was null or undefined when calling taskContentGetSingle.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling taskContentGetSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Uint8Array>('get',`${this.basePath}/task-content/${encodeURIComponent(String(contentId))}/${encodeURIComponent(String(view))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param taskDetailsId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public taskDetailsGetSingle(taskDetailsId: number, observe?: 'body', reportProgress?: boolean): Observable<TaskDetailResponse>;
    public taskDetailsGetSingle(taskDetailsId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskDetailResponse>>;
    public taskDetailsGetSingle(taskDetailsId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskDetailResponse>>;
    public taskDetailsGetSingle(taskDetailsId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (taskDetailsId === null || taskDetailsId === undefined) {
            throw new Error('Required parameter taskDetailsId was null or undefined when calling taskDetailsGetSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<TaskDetailResponse>('get',`${this.basePath}/taskDetails/${encodeURIComponent(String(taskDetailsId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param year 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksGetAll(year?: number, observe?: 'body', reportProgress?: boolean): Observable<TasksResponse>;
    public tasksGetAll(year?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TasksResponse>>;
    public tasksGetAll(year?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TasksResponse>>;
    public tasksGetAll(year?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;
        if (year !== undefined && year !== null) {
            headers = headers.set('year', String(year));
        }

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<TasksResponse>('get',`${this.basePath}/tasks`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param tasksId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public tasksGetSingle(tasksId: number, observe?: 'body', reportProgress?: boolean): Observable<TaskResponse>;
    public tasksGetSingle(tasksId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TaskResponse>>;
    public tasksGetSingle(tasksId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TaskResponse>>;
    public tasksGetSingle(tasksId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (tasksId === null || tasksId === undefined) {
            throw new Error('Required parameter tasksId was null or undefined when calling tasksGetSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<TaskResponse>('get',`${this.basePath}/tasks/${encodeURIComponent(String(tasksId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param threadDetailsId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public threadDetailsGetSingle(threadDetailsId: number, observe?: 'body', reportProgress?: boolean): Observable<ThreadDetailResponse>;
    public threadDetailsGetSingle(threadDetailsId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ThreadDetailResponse>>;
    public threadDetailsGetSingle(threadDetailsId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ThreadDetailResponse>>;
    public threadDetailsGetSingle(threadDetailsId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (threadDetailsId === null || threadDetailsId === undefined) {
            throw new Error('Required parameter threadDetailsId was null or undefined when calling threadDetailsGetSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ThreadDetailResponse>('get',`${this.basePath}/threadDetails/${encodeURIComponent(String(threadDetailsId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public threadsCreateNew(body: ThreadsCreationRequest, observe?: 'body', reportProgress?: boolean): Observable<ThreadResponse>;
    public threadsCreateNew(body: ThreadsCreationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ThreadResponse>>;
    public threadsCreateNew(body: ThreadsCreationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ThreadResponse>>;
    public threadsCreateNew(body: ThreadsCreationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling threadsCreateNew.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<ThreadResponse>('post',`${this.basePath}/threads`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param wave 
     * @param year 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public threadsGetAll(wave?: number, year?: number, observe?: 'body', reportProgress?: boolean): Observable<ThreadsResponse>;
    public threadsGetAll(wave?: number, year?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ThreadsResponse>>;
    public threadsGetAll(wave?: number, year?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ThreadsResponse>>;
    public threadsGetAll(wave?: number, year?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (wave !== undefined && wave !== null) {
            queryParameters = queryParameters.set('_wave', <any>wave);
        }

        let headers = this.defaultHeaders;
        if (year !== undefined && year !== null) {
            headers = headers.set('year', String(year));
        }

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ThreadsResponse>('get',`${this.basePath}/threads`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param threadsId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public threadsGetSingle(threadsId: number, observe?: 'body', reportProgress?: boolean): Observable<ThreadResponse>;
    public threadsGetSingle(threadsId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ThreadResponse>>;
    public threadsGetSingle(threadsId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ThreadResponse>>;
    public threadsGetSingle(threadsId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (threadsId === null || threadsId === undefined) {
            throw new Error('Required parameter threadsId was null or undefined when calling threadsGetSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ThreadResponse>('get',`${this.basePath}/threads/${encodeURIComponent(String(threadsId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param threadsId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public threadsMarkVisited(threadsId: number, observe?: 'body', reportProgress?: boolean): Observable<EmptyDict>;
    public threadsMarkVisited(threadsId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyDict>>;
    public threadsMarkVisited(threadsId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyDict>>;
    public threadsMarkVisited(threadsId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (threadsId === null || threadsId === undefined) {
            throw new Error('Required parameter threadsId was null or undefined when calling threadsMarkVisited.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyDict>('put',`${this.basePath}/threads/${encodeURIComponent(String(threadsId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param usersId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersDeleteSingle(usersId: number, observe?: 'body', reportProgress?: boolean): Observable<EmptyDict>;
    public usersDeleteSingle(usersId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyDict>>;
    public usersDeleteSingle(usersId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyDict>>;
    public usersDeleteSingle(usersId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (usersId === null || usersId === undefined) {
            throw new Error('Required parameter usersId was null or undefined when calling usersDeleteSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyDict>('delete',`${this.basePath}/users/${encodeURIComponent(String(usersId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param filter 
     * @param sort 
     * @param year 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersGetAll(filter?: string, sort?: string, year?: number, observe?: 'body', reportProgress?: boolean): Observable<UsersResponse>;
    public usersGetAll(filter?: string, sort?: string, year?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UsersResponse>>;
    public usersGetAll(filter?: string, sort?: string, year?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UsersResponse>>;
    public usersGetAll(filter?: string, sort?: string, year?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (filter !== undefined && filter !== null) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }

        let headers = this.defaultHeaders;
        if (year !== undefined && year !== null) {
            headers = headers.set('year', String(year));
        }

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<UsersResponse>('get',`${this.basePath}/users`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param usersId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersGetSingle(usersId: number, observe?: 'body', reportProgress?: boolean): Observable<UserResponse>;
    public usersGetSingle(usersId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserResponse>>;
    public usersGetSingle(usersId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserResponse>>;
    public usersGetSingle(usersId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (usersId === null || usersId === undefined) {
            throw new Error('Required parameter usersId was null or undefined when calling usersGetSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<UserResponse>('get',`${this.basePath}/users/${encodeURIComponent(String(usersId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public wavesCreateNew(body: WaveCreationRequest, observe?: 'body', reportProgress?: boolean): Observable<WaveResponse>;
    public wavesCreateNew(body: WaveCreationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WaveResponse>>;
    public wavesCreateNew(body: WaveCreationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WaveResponse>>;
    public wavesCreateNew(body: WaveCreationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling wavesCreateNew.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<WaveResponse>('post',`${this.basePath}/waves`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param waveId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public wavesDeleteSingle(waveId: number, observe?: 'body', reportProgress?: boolean): Observable<EmptyDict>;
    public wavesDeleteSingle(waveId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyDict>>;
    public wavesDeleteSingle(waveId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyDict>>;
    public wavesDeleteSingle(waveId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (waveId === null || waveId === undefined) {
            throw new Error('Required parameter waveId was null or undefined when calling wavesDeleteSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyDict>('delete',`${this.basePath}/waves/${encodeURIComponent(String(waveId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param year 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public wavesGetAll(year?: number, observe?: 'body', reportProgress?: boolean): Observable<Waves>;
    public wavesGetAll(year?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Waves>>;
    public wavesGetAll(year?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Waves>>;
    public wavesGetAll(year?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;
        if (year !== undefined && year !== null) {
            headers = headers.set('year', String(year));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Waves>('get',`${this.basePath}/waves`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param waveId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public wavesGetSingle(waveId: number, observe?: 'body', reportProgress?: boolean): Observable<WaveResponse>;
    public wavesGetSingle(waveId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WaveResponse>>;
    public wavesGetSingle(waveId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WaveResponse>>;
    public wavesGetSingle(waveId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (waveId === null || waveId === undefined) {
            throw new Error('Required parameter waveId was null or undefined when calling wavesGetSingle.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<WaveResponse>('get',`${this.basePath}/waves/${encodeURIComponent(String(waveId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param waveId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public wavesUpdateSingle(body: WaveUpdateRequest, waveId: number, observe?: 'body', reportProgress?: boolean): Observable<WaveResponse>;
    public wavesUpdateSingle(body: WaveUpdateRequest, waveId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WaveResponse>>;
    public wavesUpdateSingle(body: WaveUpdateRequest, waveId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WaveResponse>>;
    public wavesUpdateSingle(body: WaveUpdateRequest, waveId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling wavesUpdateSingle.');
        }

        if (waveId === null || waveId === undefined) {
            throw new Error('Required parameter waveId was null or undefined when calling wavesUpdateSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<WaveResponse>('put',`${this.basePath}/waves/${encodeURIComponent(String(waveId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public yearsCreateNew(body: YearCreationRequest, observe?: 'body', reportProgress?: boolean): Observable<YearResponse>;
    public yearsCreateNew(body: YearCreationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<YearResponse>>;
    public yearsCreateNew(body: YearCreationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<YearResponse>>;
    public yearsCreateNew(body: YearCreationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling yearsCreateNew.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<YearResponse>('post',`${this.basePath}/years`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param yearId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public yearsDeleteSingle(yearId: number, observe?: 'body', reportProgress?: boolean): Observable<EmptyDict>;
    public yearsDeleteSingle(yearId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EmptyDict>>;
    public yearsDeleteSingle(yearId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EmptyDict>>;
    public yearsDeleteSingle(yearId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (yearId === null || yearId === undefined) {
            throw new Error('Required parameter yearId was null or undefined when calling yearsDeleteSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<EmptyDict>('delete',`${this.basePath}/years/${encodeURIComponent(String(yearId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public yearsGetAll(observe?: 'body', reportProgress?: boolean): Observable<Years>;
    public yearsGetAll(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Years>>;
    public yearsGetAll(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Years>>;
    public yearsGetAll(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Years>('get',`${this.basePath}/years`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param yearId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public yearsGetSingle(yearId: number, observe?: 'body', reportProgress?: boolean): Observable<YearResponse>;
    public yearsGetSingle(yearId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<YearResponse>>;
    public yearsGetSingle(yearId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<YearResponse>>;
    public yearsGetSingle(yearId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (yearId === null || yearId === undefined) {
            throw new Error('Required parameter yearId was null or undefined when calling yearsGetSingle.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<YearResponse>('get',`${this.basePath}/years/${encodeURIComponent(String(yearId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param yearId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public yearsUpdateSingle(body: YearUpdateRequest, yearId: number, observe?: 'body', reportProgress?: boolean): Observable<YearResponse>;
    public yearsUpdateSingle(body: YearUpdateRequest, yearId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<YearResponse>>;
    public yearsUpdateSingle(body: YearUpdateRequest, yearId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<YearResponse>>;
    public yearsUpdateSingle(body: YearUpdateRequest, yearId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling yearsUpdateSingle.');
        }

        if (yearId === null || yearId === undefined) {
            throw new Error('Required parameter yearId was null or undefined when calling yearsUpdateSingle.');
        }

        let headers = this.defaultHeaders;

        // authentication (ksi) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<YearResponse>('put',`${this.basePath}/years/${encodeURIComponent(String(yearId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
